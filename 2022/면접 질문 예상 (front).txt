
--------------------------------------------------------------------------------------------------------------------------------------
1. Http requset, response
: Http 메시지
HTTP 요청은 서버가 특정 동작을 취하게끔 만들기 위해 클라이언트에서 전송하는 메시지
HTTP 응답의 시작 줄은 상태 줄(status line)

http1.1 / 2.0
=> 속도차이
헤더 정보를 HPACK 방식으로 압축한다.
리소스 간의 의존관계에 따른 우선순위를 설정 시에 여러 개의 메시지를 주고 받을 수 있음

2. Http staus code
: HTTP 요청 응답코드 
1xx (정보): 요청을 받았으며 프로세스를 계속한다.
2xx (성공): 요청을 성공적으로 받았으며 인식했고 수용하였다. 
3xx (리다이렉션): 요청 완료를 위해 추가 작업 조치가 필요하다.
4xx (클라이언트 오류): 요청의 문법이 잘못되었거나 요청을 처리할 수 없다.
5xx (서버 오류): 서버가 명백히 유효한 요청에 대해 충족을 실패했다.

3. HTML 파싱
: 브라우저 로더 -> css,html 파싱 -> html 파싱(돔 트리 생성), cssom 생성 -> 자바스크립트엔진(번역)
-> 렌더링엔진(렌더링트리) ->  css결정 -> 레이아웃(배치[렌더링엔친 크기, 위치 계산])-> 페인트(그리기)

4. Reflow와 Repain
: reflow -> 이벤트나 액션에 따라 html 요소 크기, 위치 등 레이아웃 수치 수정 시 레이아웃과정(렌더트리 크기,위치계산) 다시 수행 이 과정을 뜻함
: repaint -> Render Tree 다시 화면에 그려 주는 과정
reflow가 일어나야 반드시 repaint가 일어나는 것은 아니다
레이아웃과정을 거치지 않는 행위(크기,배치 가 달라지지 않는 행위) 발생시 reflow를 수행 할 필요(X) repaint만 수행

5. javascript

실행컨텍스트 : 
실행 가능한 코드를 형상화하고 구분하는 추상적인 개념(코드실행 환경,  자바스크립트가 왜 그렇게 동작하는지
코드를 구분하는 과정)

1번
전역 컨텍스트 ,함수 컨텍스트 2가지 존재
전역 컨텍스트 하나 생성 후에 함수 호출할 때마다 함수 컨텍스트가 생성
컨텍스트를 생성시에 변수객체, 스코프 체인, this가 생성된다
컨텍스트 생성 후 함수가 실행, 사용되는 변수들은 변수 객체 안에서 값을 찾고 없다면 스코프체인을 따라 올라가며 찾음

2번
실행 컨텍스트 동작 순서 상세
1) 전역 코드 평가 : 변수/함수 먼저 선언, 전역 변수/전역함수를 전역 스코프에 등록
2) 전역 코드 실행 : 런타임 시작, 전역 코드가 순차 실행 ⇢ 전역 변수에 값 할당, 함수 호출 ⇢ 함수 컨텍스트 생성(실행)
3) 함수 코드 평가 : 함수 컨텍스트에 있는 매개변수와 지역 변수 선언 ⇢ 매개변수, 지역 변수 실행 컨텍스트가 관리하는 지역 스코프 등록 
⇢ arugments 객체 생성 및 지역 스코프에 등록, this 바인딩 결정
4) 함수 코드 실행 : 런타임 시작 함수 코드 순차 실행 ⇢ 매개변수, 지역 변수에 값 할당, 내부에 있는 매서드 등 실행

=> 즉, 자바스크립트의 코드가 실행되기 위해 변수객체, 스코프체인, this 정보들을 담고 있는 곳을 실행컨텍스트라고 부른다.

--------------------------------------------------------------------------------------------------------------------------------------

클로저 : 

비공개 변수를 가질 수 있는 환경에 있는 함수가 클로저
클로저는 자신이 생성될때의 환경을 기억하고 환경 밖에서 호출되도 그 환경에 접근할  함수이다.
재활용할 수 있다(함수 호출 시 초기값 유지)

사용 하는 이유 :
1) 현재 상태를 기억하고 변경된 최신 상태를 유지하기 위해
2) 전역 변수의 사용을 억제 하기위해
3) 내부 함수 유츨되지 않음(정보 은닉)

단점: 프로그램 종료될 때 까지 남아있어서 메모리 낭비

/*
비공개 변수:
function(){
console.log(name)
}
name은 closure 함수의 매개변수도 아니고, closure 함수 내부에서 생성한 변수도 XX

이 경우 
function(){
console.log(name)
}
은 name 변수나, name 변수가 있는 스코프에 대해 클로저 라고 부를 수다(자유변수).
*/

--------------------------------------------------------------------------------------------------------------------------------------

AJAX란 무엇인가

자바스크립트를 이용해 비동기적으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식
보통은 서버로부터 웹페이지가 반환되면 전체를 갱신해야하는데 / AJAX를 사용하면, 페이지 일부만을 갱신하고도 
동일한 효과를 볼 수 있다. 즉, 갱신이 필요한 부분만 로드하여 갱신하면 되므로 빠르고, 부드러운 화면효과를 기대할 수 있음

--------------------------------------------------------------------------------------------------------------------------------------

Callback과 Promise

둘 다 자바스크립트에서 비동기처리를 위해서 사용되는 패턴이며, 
Callback 같은 경우 함수의 처리 순서를 보장하기 위해서 함수를 중첩하게 사용되는 경우가 발생
해백헬이 발생하는 단점과 에러처리가 힘들다라는 단점이 있다. 

그래서 나온게 Promise이며 ES6부터 정식 채택되어 사용중이다. Promoise이다.

/*
Promise란 : 
프로미스는 자바스크립트 비동기 처리에 사용되는 객체입니다. 
주로 서버에서 받아온 데이터를 화면에 표시할 때 사용
정상적으로 기능이 수행되고나면 성공의 메시지와 처리된 결과값을 보여주고, 예상치 못한 문제가 발생하면 에러값을 보여준다

Promise 처리 과정
new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 갖습니다.
Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태
Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태
Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태
*/

--------------------------------------------------------------------------------------------------------------------------------------
이벤트큐 : 
	
자바스크립트 엔진은  콜 스택(Call stack)과 메모리 힙(Memory Heap)으로 구성되어 있고 
한 번에 태스크(task) 1개만 처리하는 싱글스레드 방식이다.

싱글 스레드에서 여러 가지 일이 동시에 실행되는 것처럼 보이는 자바스크립트의 동시성(Concurrency)은 
바로 이벤트 루프(Event Loop)를 통해 구현

이벤트 루프는 스택이 비워지고 나서 태스크 큐에 있는 함수를 순차적으로 콜 스택으로 넣어주기 때문에, 자바의
동시성이 일어남(보류)


1. 콜 스택
함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행된다. 
자바스크립트는 단 하나의 콜스택을 사용하기 때문에 실행 중인 실행 컨텍스트가 종료되어
콜 스택에서 제거되기 전까지는 다른 태스크는 실행시키지 않는다.
(함수 호출 -> 함수 실행컨텍스트 -> 콜스텍 저장 -> 종료될 때까지 다른 함수 실행되지 않음, 즉 순차적으로 실행됨)

2.메모리 힙
객체가 저장되는 메모리 공간, 콜 스택이 푸쉬된 함수가 실행될 때 메모리 힙에 저장된 해당 객체를 참조하여 실행

3.태스크 큐
setTimeout 이나 setInterval 같은 비동기 함수의 콜백 함수, 이벤트 핸들러가 일시적으로 보관되는 영역이다.

4.이벤트 루프
이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 
태스크 큐에 대기중인 함수(콜백 함수, 이벤트 핸들러..)가 있는지 반복해서 확인한다. 
콜스택이 비어 있고 태스크 큐에 대기중인 함수가 있다면 이벤트 루프는 순차적으로
태스크 큐에 대기 중인 함수를 콜스택으로 이동시킨다. 이때 콜 스택으로 이동한 함수는 실행된다.

--------------------------------------------------------------------------------------------------------------------------------------

얕은 복사와 깊은 복사 : 

깊은 복사(Deep Copy)는 '실제 값'을 새로운 메모리 공간에 복사하는 것을 의미
얕은 복사(Shallow Copy)는 '주소 값'(참조)을 복사
얕은 복사의 경우 주소 값을 복사하기 때문에, 참조하고 있는 실제값은 같습니다.

얕은 복사는
장점: 객체 공유 , 메모리 절약, 빠름
단점: 같은 대상 가리킴, 동시 수정

깊은 복사는
똑같은 구조를 복사 생성, 변경에 안전
생성 비용 비쌈, 메모리 많이 점유

--------------------------------------------------------------------------------------------------------------------------------------

var와 let, const의 차이 : 

let 은 변수에 재할당이 가능
const는 변수 재선언, 변수 재할당 모두 불가능

자바스크립트는 모든 선언을 호이스팅하지만
var 로 선언된 변수와는 달리 let 로 선언된 변수를 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생
(코드 상단에서 console.log(a)를 찍고 하단에서 var a=1; 이라고 하였을때 a는 undefined라고 나온다)
(즉, 선언이 되었지만 값이 할당 되지 않아 정의되어있지 않은 상태, 오류가 나야 이러한 오류를 잡기 쉽다 따라서 let과 const가 나옴)

var 으로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다
let 로 선언된 변수는 선언 단계와 초기화 단계가 분리

변수 선언에는 기본적으로 const를 사용하고, 재할당이 필요한 경우에 한정해 let 을 사용하는 것이 좋다.

--------------------------------------------------------------------------------------------------------------------------------------

가비지컬렉터의 역할은? 어떻게 동작?

메모리 할당을 추적하고 할당된 메모리 영역이 필요하지 않은 영역일 경우를 판단해서 회수하는 것. 
자바스크립트에서 변수는 직접적으로 참조 값(문자열, 객체, 배열 등)을 담고 있지 않고, 해당 값을 메모리 상에 저장 된다. 

그래서 참조 값을 생성하고나서 더이상 참조할 것이 없거나 비어졌을 때 가비지 컬렉터가 동작해서 메모리가 반환됨
(메모리를 다시 재사용할 수 있는 상태가 된다)

--------------------------------------------------------------------------------------------------------------------------------------

비동기란 :
요청을 보낸 동시에 일어나는 게 아니라 요청을 보내고 그 시간동안 다른 작업을 할 수 있어 효율적임
(자바스크립트의 비동기 처리란 ‘특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행하는 자바스크립트의 특성(싱글스레드)
--------------------------------------------------------------------------------------------------------------------------------------
프로토타입이란?

자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거(중복 제거 방법은 기존의 코드를 재사용하는것!!)

즉, 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해 놓음으로써 또 
구현하는것이 아니라 상위(부모) 객체인 프로토타입의 자산을 공유하여 사용할 수 있다. 

__proto__ 접근자 프로퍼티로 자신의 프로토타입, 즉 Prototype 내부슬롯에 접근 할 수 있음. 
--------------------------------------------------------------------------------------------------------------------------------------
프로토타입체인이란? 

객체의 프로퍼티에 접근하려고 할때 객체에 접근하려는 프로퍼티가 없으면, __proto__접근자 프로퍼티가 가리키는 
링크를 따라 자신의 부모역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 

프로로타입체인의 최상위 객체는 Object.prototype이다. 
이 객체의 프로퍼티와 메소드는 모든 객체에게 상속된다. prototype 프로퍼티 는 생성자함수가 생성할 인스턴스의 프로토타입을 가르킨다.
--------------------------------------------------------------------------------------------------------------------------------------
자바스크립트에서 This는 몇가지로 추론 될수 있는가, 아는대로 말해달라

일반함수의 this와 화살표 함수의 this는 어떻게 다른가?
자바스크립트의 내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든지 this는 전역객체를 가르킴

일반함수의 this는 window(전역)을 가르키며,
화살표 함수의 this는 언제나 상위 스코프의 this를 가르킴

/*
Call, Apply, Bind 함수에 대해 설명해달라
3가지 방법은 this를 바인딩하기 위한 방법이다. 

Call은 this를 바인딩하면서 함수를 호출하는 것, 두번째 인자를 apply와 다르게 하나씩 넘기는 것
Apply는 this를 바인딩하면서 함수를 호출하는 것, 두번째인자가 배열
Bind는 함수를 호출하는 것이 아닌 this가 바인딩 된 새로운 함수를 리턴함
*/

--------------------------------------------------------------------------------------------------------------------------------------
크롬 정도의 브라우저를 제외하곤 ES6 스펙에 대한 지원이 완벽하지 않다. 
해결방법은 무엇인가

Babel을 사용한다. ES6이상의 문법의 코드들을 브라우저가 이해할 수 있게끔 ES5이하의 문법으로 변환

Babel이란?
babel은 컴파일러 인가 ? 트랜스파일러인가?

트랜스파일러이다. 
컴파일은 한 언어로 작성된 소스 코드를 다른 언어로 바꾸는것(C-> 어셈블리어)
트랜스파일러는 한언어로 작성된 소스코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환(C++>C, ES6->ES5)

즉, 바벨은 현재 언어를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 일종의 번역기(변환기)이다.
--------------------------------------------------------------------------------------------------------------------------------------
ES6 에서 추가된 스펙에 대해 아는대로 다 말해달라
let, const, 화살표함수, 클래스, 프로미스 등
--------------------------------------------------------------------------------------------------------------------------------------
Webpack이란?
: 가장 많이 사용 되는 모듈 번들러
: 애플리케이션을 구성하는 자원 (html, css, js, image ...)등을 모두 각각의 모듈로 보고
이를 조합해서 병합된 하나의 결과물을 만드는 도구
--------------------------------------------------------------------------------------------------------------------------------------
Prettier가 무엇인가요?

들여쓰기, 띄어쓰기

개발자가 작성한 코드를 정해진 코딩 스타일을 따르도록 변환해주는 도구를 말합니다. 
Prettier는 이러한 코드 포멧터 중에서도 최근에 가장 인기를 많이 얻어 거의 표준이 되고 가고 있는 자바스크립트 라이브러리
장점으로는 협업하는 모든 개발자가 따옴표라던지 탭 스타일이라던지 모두 동일하게 적용할 수 있다

--------------------------------------------------------------------------------------------------------------------------------------
Eslint가 무엇인가요? 

자바스크립트는 에러를 찾기위해 직접 실행해봐야한다. 따라서 이전에 문법 오류나 에러를 잡아주는 것
prettier는 code의 스타일을 말한다면 이는 코드의 문법을 사전에 검사하여 에러를 잡아주고 간단한 코드 스타일을 해줄 수 있다

--------------------------------------------------------------------------------------------------------------------------------------
TypeScript

자바스크립트에는 타입이 정해져있지 않은 동적 타입의 언어이다. (ex let과 const)
이러한 경우 컴파일 단계가 아닌 런타임(실행 시) 단계에서 오류가 나게 되는데 이를 방지하고자
타입스크립트로 타입을 정해주어 (ex let a:number) 컴파일 단계에서 오류를 해결할 수 있도록 도와주는
정적 타입 언어이다.

--------------------------------------------------------------------------------------------------------------------------------------

npm과 yarn 그리고 npx

패키지 관리툴
- 세가지 모두 Node 프로젝트에서 설치되는 패키지나 라이브러리들을 관리해 주는 패키지 관리툴
- 리엑트는 여러가지 오픈 소스 라이브러리(도구)들을 빌려와 개발

npm
- 노드의 기본 패키지 관리 툴
- 사용 빈도가 가장 높음
- 리엑트 프로젝트 설치 시 라이브러리를 다운로드 받아야하는데 무겁기 때문에 npm을 활용해서 프로젝트를 만들진 않습니다
- npm install 패키지명 
- npm i 패키지명

npx
- npm과 달리 패키지를 실행만 시켜주는 도구
- 개발을 하는 입장이라면 npm과 npx의 차이를 느끼지는 못함
- 단, npx를 사용하면 리엑트 프로젝트 설치 시 라이브러리를 다운 받지 않아도 되기 때문에 실행할 수 있습니다
- npm 5.2이상부터는 기본 패키지 관리툴에 포함 (npm -v로 확인)

yarn
- 과거 npm보다 속도, 안정성 모두 뛰어나 이목을 끌었음
- 현재 속도 안정성 모두 npm이 따라 잡은 상태
- 그러나 보안성에 있어서 만큼은 npm과 npx와 결이 다르다
- 하지만, npm이 가장 많이 쓰이기 때문에 yarn을 지원하지 않는 라이브러리 들이 존재
- 사용법 npm install -g yarn
- yarn add 패키지명

--------------------------------------------------------------------------------------------------------------------------------------
반응형 프로그래밍

반응형 프로그래밍은 (Reactive Programming) 주변 환경과 끊임없이 상호작용을 하는 프로그래밍을 의미
프로그램이 주도하는 것이 아니라 환경(예를 들어 데이터)이 변하면 이벤트를 받아 동작하도록 만드는 프로그래밍 기법을 말합니다. 
반응형 프로그램은 외부 요구에 끊임없이 반응하고 처리

--------------------------------------------------------------------------------------------------------------------------------------
CORS(Cross-Origin Resource Sharing) Error

서버는 browser/client/server/database 로 구성되어 있는데, browser와 client는 도메인이 동일하고 
server, database는 도메인이 다르다. 이 때 브라우저가 서버로 요청을 보낼 때 cors 에러가 발생하는데 같은 도메인일 때는 
에러가 없지만 다른 도메인일 때는 보낼 수 없도록 되어있다. 그래서 cors 미들웨어를 통해 client에서 server의 도메인을 
연결해서 브라우저는 클라이언트에게 요청을, 클라이언트는 서버에게 요청을 보내면서 응답하는 방식으로 해결할 수 있다. 
이 방식을 proxy 방식이라고 한다.

--------------------------------------------------------------------------------------------------------------------------------------
REST REST(Representational State Transfer)의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미

REST API는 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스이고 REST의 특징을 기반으로한 API
각 요청이 어떤 동작이나 정보를 위한 것인지를 요청한 모습 자체로도 해석이 가능하다는 특징이 있다. 

ex) GET /members/delete/1 ---> 잘못된 경우
     DELETE /member/1 -------> o

즉 get,post,patch,delete 와 같은 HTTP method를 통해 자원의 행위를 표현하고
URI로 자원을 표현하는 등 한눈에 알아보기 쉽게 작성되어야 한다는 것

RESTful API는 REST의 설계 규칙을 잘 지킨 API
--------------------------------------------------------------------------------------------------------------------------------------
메모이제이션이란?

- 만약 어떠한 연산이나 함수가 복잡하여 결과가 오래걸린다.
- 리엑트는 상태가 바뀌면 렌더링 된다. 
- 하지만 랜더링 될 때 이 복잡한 함수 및 연산이 값이 바뀌지 않는 부분이라면, 한번 더 실행해야할까?
- 값이 안바뀌는 연산의 값을 저장하여 랜더링 되더라도 해당 부분 함수나 연산을 실행하지 않고 값만 재사용하는 것, 
- 즉 랜더링이 필요 없는 연산의 시간을 줄여줌
--------------------------------------------------------------------------------------------------------------------------------------
메소드 체이닝이란 무엇

메소드를 통해 메소드를 호출하는 것
ex)  leader.up().down().up().down()
--------------------------------------------------------------------------------------------------------------------------------------
라이프 사이클 메소드란

라이프 사이클 (생명주기)
페이지가 마운트 (열렸을 때 ) ~ 종료될 때 (꺼졌을 때) 이 주기 동안 특정 작업을 처리해야하는 경우 사용하는 메소드

컴포넌트를 처음으로 렌더링할 때(또는 컴포넌트를 업데이트하기 전후) 특정 작업을 처리해야 하는 경우, 불필요한 업데이트를 방지해야 하는 경우

* 클래스형 컴포넌트에서만 사용 가능
* 함수형 Hooks 기능을 통해 함수형 컴포넌트에서 비슷한 작업을 처리할 수 있다
--------------------------------------------------------------------------------------------------------------------------------------
state 불변성

   불변성
   어떤 값을 직접적으로 변경하지 않고 새로운 값을 만들어내는 것

   const obj = {}
   const obj2 = {}
   const obj3 = obj // obj와 같은 참조 값을 가진다
   
   따라서 obj 가지고 있는 객체의 값이 변경되면 obj3도 같은 객체를 가지기 때문에 값이 공유된다.
   즉 데이터의 원본이 훼손되고 이러한 훼손은 예기치 못하는 오류나 버그가 발생할 수 있으므로 객체를 복사해서 새로 만들어내는 것
   
   React는 값이 바뀌어야 랜더링
   직접 변경하게 되면 바뀐 상태와 값이 동일해지기 때문에 비교할 수가 없음 따라서 값이 변경되었는지 알기위해서 불변성을 지켜준다
--------------------------------------------------------------------------------------------------------------------------------------
Callback 지옥이란 : 
콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들정도로 깊어지는 현상을 얘기합니다.
주로 이벤트 처리나 서버 통신과 같은 비동기적인 작업을 수행하기 위해 이런 형태가 자주 등장하는데, 
가독성이 떨어지면서 코드를 수정하기 어렵습니다.

콜백 지옥 탈출 1. 기명함수
- 코드의 가독성을 높일 수 있고 함수 선언과 함수 호출만 구분할 수 있다면 위에서부터 아래로 순서대로 읽는데 어려움이 없습니다.
콜백 지옥 탈출 2. Promise
- resolve 또는 reject를 호출
콜백 지옥 탈출 3. Generator
- 비동기 작업이 완료되는 시점마다 next메서드를 호출하면 Generator함수 내부의 소스가 위에서부터 아래로 순차적으로 진행됩니다.
콜백 지옥 탈출 4. Promise + async/await
--------------------------------------------------------------------------------------------------------------------------------------
호이스팅 : 
자바스크립트의 모든 선언에는 호이스팅이 일어난다.
코드가 실행하기 전 변수선언/함수선언이 해당 스코프의 최상단으로 끌어 올려진 것 같은 현상을 말한다.
let, const, class를 이용한 선언문을 호이스팅이 발생하지 않는 것처럼 동작한다.
var 키워드로 선언된 변수와는 달리 let 키워드로 선언된 변수를 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생한다.
--------------------------------------------------------------------------------------------------------------------------------------
async, await :
비동기식 콜백함수를 좀 더 쉽게 작성할 수 있게 함, async는 promise를 반환한다.

await은 값이 반환되기 전까진 내부 함수를 동작하지 않는다.
=> 동기적인 코드흐름으로 개발이 가능하다.
---------------------------------------------------------------------------------------------------------------------------------
React작동원리
React구현 핵심 컨셉 & V-DOM에 대한 이해

React란?

React는 사용자 인터페이스를 구축하기 위한 JavaScript 라이브러리입니다. 

리엑트 구현 컨셉은 "컴포넌트와", "리렌더"입니다.

컴포넌트”라고 불	리는 작고 고립된 코드의 파편을 이용, 복잡한 UI를 유연하게 구성하도록 돕습니다.
이러한 과정에서 사용자들에게 화면에서 보고자 하는 내용을 구현하는 rander 함수를 이용하는데
reander는 htm과 비슷한  “JSX”라는 특수한 문법을 사용하여 React의 구조를 보다 쉽게 작성할 수
있으며 state라 불리는 컴포넌트 내 데이터 객체를 이용하여 데이터들이 변경(업데이트) 이 되면 
render 함수가 자동적으로 재호출, 즉 리랜더 하게 됩니다.

/*
컴포넌트:
한가지의 기능을 수행하는 UI 단위
각각의 독립적인 컴포넌트 단위들을 서로 조립해서 만들은 것 리액트 어플리케이션이라고 할 수 있다. 
컴포넌트도 DOM Tree 처럼 하나의 Virtual DOM Tree 라는 Tree 형식으로 만들어져 있다.
*/
---------------------------------------------------------------------------------------------------------------------------------
Virtual DOM Tree ( 가상 돔 트리 )
=> React 가 가지고 있는 가상의 DOM Tree 를 말한다.

업데이트 이전의 가상 돔 트리 상태와, 업데이트 이후의 가상 돔 트리 상태를 비교
업데이트 되는 내용이 있다면 그때 Real(진짜) DOM Tree 를 업데이트 한다.

Virtual DOM은 뷰에 변화가 있다면, 그 변화가 실제 DOM에 적용되기 전에 Virtual DOM에 
적용시키고 최종 결과만 실제 DOM에 전달합니다. 따라서 20개의 변화가 있다면 Virtual 
DOM은 변화된 부분만 가려내어 실제 DOM에 전달하고 실제 DOM은 그 변화를 1회로 인식
하여 단 한번의 렌더링 과정만 거치게 됩니다.
---------------------------------------------------------------------------------------------------------------------------------
useEffect, useMemo, useCallback에 대한 이해와 활용방법	

useMemo = 값을 저장 (함수의 return값)
- 변경되는 값이 없다면 한번만 실행 후 값을 보관하는 역할로 사용하는것이 좋음
- useMemo는 매 번 render할 때마다 메모리가 많이 소모되는 값들을 계산하지 않고 functional components를 최적화하는데 도움을 준다.

useCallback = 함수를 저장
- 함수 생성 자체가 오래걸리는 경우 (= 함수 내에 연산이 복잡한 경우)에 사용하면 최적화에 도움됨
- 변경되는 값을 기억할 수 있음 (변경되는 값이 없으면 초기값만 기억)

useEffect 
- 컴포넌트가 렌더링될 때 특정 작업을 실행하는 hook

/*
- didmount
첫번째 렌더링을 마치고 나면 호출되는 메소드 / 이 메소드가 호출되는 시점에는 모든 컴포넌트가 화면에 나타난 상태다.
(dependency 빈배열이면 한번만 실행)

- didupdate
리렌더링을 마치고 화면에 원하는 변화가 모두 반영되고 나면 호출되는 메소드 
(dependency 배열에 state넣으면 갱신마다 실행)

- willunmount
컴포넌트가 화면에 사라지기 직전에 호출되는 메소드
(컴포넌트가 어떤 이유로 인해 지워진다면 해당 이벤트도 반드시 지워야함, 이벤트 함수 반환)
*/

---------------------------------------------------------------------------------------------------------------------------------
CSR과 SSR의 차이?
CSR의 과정 :
 - 서버가 브라우저에게 응답을 보냄 -> 브라우저는 JS를 다운 받음 -> 브라우저는 리액트를 실행 -> 페이지가 보여지고 상호작용 함

SSR의 과정 : - 서버가 브라우저에게 HTML 응답 랜더링하기 위한 준비가 되었다고 보냄 -> 브라우저가 페이지랜더링, 
페이지가 보여지고 브라우저는 JS 다운받음 -> 브라우저 리액트 실행 -> 페이지 상호작용 가능

CSR은 마지막 단계 전까지 화면에 보여지지가 않고 로딩중 / SSR은 미리 페이지가 보여진다. 
즉, CSR은 초기로딩속도가 느리긴하지만, 화면전환에 있어서 클라이언트에서 이루어져서 빠른 전환이 가능

SSR은 초기로딩속도가 빨라서 사용자가 느끼기엔 좋지만, 동작은 하지않음. 
그리고 화면전환에 있어서 서버에 요청해야하므로 서버에 부담을 줄 수 있음. 어떤게 더 좋다보다 서비스마다 사용자의 요구마다 다름.
---------------------------------------------------------------------------------------------------------------------------------
적응형과 반응형의 차이를 아는가?
반응형 웹은 하나의 템플릿을 사용해 모든 기기에 대응하는데 반해, 적응형 웹은 선별된 기기 
유형에 따라 별도의 독립적인 템플릿이 요구
---------------------------------------------------------------------------------------------------------------------------------
Angular와 React의 차이점은 무엇이라고 생각?

우선 Angular는 프레임워크이고, React는 라이브러리이다.

Angular는 양방향 바인딩개념으로 Model과 view가 연결되어있어 데이터 값이 한쪽에서 변화하면 다른쪽에서도 바로 업데이트가
진행된다. 서비스라는 개념은 컴포넌트간의 의존성관리를 용이하게 해준다. Directive를 이용하여 커스텀 HTML태그를 작성할 수 있다. 

React는 Virtual DOM을 가지고 있다. 가상 DOM이 있기때문에 상태를 비교하여 부분적으로 랜더링 할 수 있어 속도가 빠르다. 
오직 UI 컴포넌트를 만들기 위한 라이브러리이다. 

Angular는 HTML스크립팅이 templete 기반, React는 JSX 이용 / 
Angular는 기본이 Typesciprt

/*
라이브러리와 프레임워크에 대해서 설명

라이브러리와 프레임워크의 차이는 자유도의 차이 인것 같다. 

프레임워크는 짜여진 패턴이나 틀 기반에서 내가 코딩을 하는 것이고, 
라이브러리는 내가 가져다 사용해서 자유롭게 사용하는 방식이다
*/
---------------------------------------------------------------------------------------------------------------------------------
package.json에서 dependencies와 devDependencies의 차이는?

프로세스와 스레드의 차이 
프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 스레드는 프로세스가 할당받은 
자원을 이용하는 실행 단위이다. 멀티프로세싱보다 멀티스레딩을 하는 이유는 운영체제로부터 
자원을 할당 하는 프로세싱 작업을 많이 하는 것 보다 스레딩을 여러개 하는것이 훨씬 더 시
스템 자원을 효율적으로 관리할 수 있다.
---------------------------------------------------------------------------------------------------------------------------------
이벤트 위임이란?
이벤트 위임이란 자식 엘리먼트의 이벤트를 부모엘리먼트에서 감지할 수 있으니 이벤트를 하
나하나 등록하는 것이 아니라 부모에게 이벤트를 위임 하는 방법
---------------------------------------------------------------------------------------------------------------------------------
inline vs inline block ?

inline은 text크기만큼만 공간을 점유하고 줄바꿈을 하지않음.

inline-block은 inline속성과 block속성의 특징을 둘다 가지고 있다. inline속성과 다르게 
width,height 적용 가능하고 line-height를 커스텀하게 적용할 수 있다
---------------------------------------------------------------------------------------------------------------------------------
vue와 React의 차이? 
공통점으로 컴포넌트 기반이다. Virtual DOM 방식이다. 가볍고 빠르다. 

vue는 단일 파일 컴포넌트이다. html, css, javascript코드가 하나의 파일에 모두 정의하는 방식이 기본이지만, 컴포넌트화 해서 사용할 수 있음!! 
HTML 기반 템플릿 구문을 가진다. -> 배우기 쉬움
---------------------------------------------------------------------------------------------------------------------------------
null vs undefined ?

기본적으로 둘다 값이 없음을 나타낸다. 

undefiend는 데이터 타입이자 값을 나타냄. 정의되지 않은 것.
null은 명시적으로 값이 비어있음을 나타내는데 사용.
undefined는 변수를 선언만 한더라도 할당되지만, null은 변수를 선언한 후에 null로 값을 지정.
--------------------------------------------------------------------------------------------------------------------------------
이벤트 버블링
- 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가 더 상위의 화면 요소들로 전달되어 가는 특성
   (하위에서 상위 요소로의 이벤트 전파 방식)
- 최하위 요소를 클릭했을 때 그 위의 상위요소들까지 이벤트가 전파되어 이벤트가 발생됨

이벤트 캡쳐링
- 해당 이벤트를 감지하기 위해 이벤트 버블링과 반대 방향으로 탐색
 (상위에서 하위 요소로의 이벤트 전파 방식)
- 최상위 요소에서 클릭 이벤트가 발생한 태그를 찾아 내려감
-----------------------------------------------------------------------------------------------------------------------------------
리액트로 했던 프로젝트에서 구현하기 까다로웠던 부분이나 코드 구조를 어떻게 잡았는지 등 프로젝트 위주의 질문
-----------------------------------------------------------------------------------------------------------------------------------

goole.com을 검색했을 때 일어나는 일

구조
google.com -> url 파싱 -> DNS서버 탐색 -> TCP connection  -> FIRST GET REQUEST -> HTML PARSING 

요약
google.com 을 입력하면 URL 주소 중 도메인 네임 부분을 DNS 서버에서 검색
DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달 
HTTP 프로토콜을 사용하여 요청 메시지를 생성하고 HTTP 요청 메시지는 TCP/IP 프로토콜을 사용하여 서버로 전송
웹서버는 데이터를 받고 response 메시지를 생성하여 다시 브라우저에게 데이터를 전송 브라우저는
response를 받아 파싱(HTML파싱)하여 화면에 렌더링

여기서 브라우저로부터 서버가 요청을 받으면,
웹서버는 페이지의 로직이나 데이터베이스(DB)의 연동을 위해 WAS(웹어플리케이션서버)에게 이들의 처리를 요청한다.
그러면 WAS는 이 요청을 받아 동적인 페이지처리를 담당하고, DB에서 필요한 데이터 정보를 받아서 파일을 생성한다.

주석
/*
OSI 7 Layer
OSI 참조 모델은 
데이터 통신을 7단계로 나누는데 이 단계를 계층(Layer) 라고 부른다.
(물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용)

TCP/IP 프로토콜
데이터가 어떻게 웹을 건너 여행하는지 정의하는 통신 규약
IP주소를 사용해서 데이터를 전달하고 그 데이터가 제대로 갔는지에 대해 이야기하는 것

DNS서버(Domain Name System Servers)
URL들의 이름과 IP주소를 저장하고 있는 데이터베이스로, 웹사이트를 위한 주소록
숫자로 된 IP주소(ex. 63.245.217.105) 대신 사용자가 사용하기 편리하도록 주소를 매핑해주는 역할

웹서버 : 정적인 컨텐츠(HTML, CSS, IMAGE 등)를 요청받아 처리
WAS : 동적인 컨텐츠(JSP, ASP, PHP 등)를 요청받아 처리 (웹 서버 혼자서 모든 로직을 수행하고 데이터를 관리할 수 있다면 간단하겠지만,
그렇게 될 경우엔 서버에 과부하가 일어날 수 있다. 그렇기 때문에 서버의 일을 돕는 조력자 역할을 하는 것)

=> DB서버에 대한 접속 정보가 있기 때문에 외부에 노출 될 경우 보안상의 문제를 이유로 웹서버와의 연결을 통해 요청을 전달받음
*/

정리
=>
1. 사용자가 웹브라우저 검색창에 www.google.com 입력
2. 웹브라우저는 캐싱된 DNS 기록들을 통해 해당 도메인주소와 대응하는 IP주소를 확인
3. 웹브라우저가 HTTP를 사용하여 DNS에게 입력된 도메인 주소를 요청
4. DNS가 웹브라우저에게 찾는 사이트의 IP주소를 응답
5. 웹브라우저가 웹서버에게 IP주소를 이용하여 html문서를 요청
6. 웹어플리케이션서버(WAS)와 데이터베이스에서 우선 웹페이지 작업을 처리
7. 위의 작업처리 결과를 웹서버로 전송
8 웹서버는 웹브라우저에게 html 문서결과를 응답
9. 웹브라우저는 화면에 웹페이지 내용물 출력(파싱)

-----------------------------------------------------------------------------------------------------------------------------------
알고리즘
스택, 큐, 힙, Hash, Hashmap, Treeset, sorting, searching, dfs, bfs, recursive, greedy 

스택 - 데이터를 임시 저장할 때 사용하는 자료구조로, 데이터의 입출력 순서는 후입선출(FILO) 구조이다.
큐 - 스택과 같이 데이터를 임시 저장하는 자료구조로, 선입선출(FIFO) 구조이다.
dfs - 깊이 우선 탐색이라고 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.
       (스택 자료구조를 이용)
bfs - 너비 우선 탐색 알고리즘으로, 가까운 노드부터 탐색하는 알고리즘이다.
       (큐 자료구조를 이용, 최대한 멀리 있는 노드를 우선으로 탐색하는 DFS와는 반대)
greedy - 탐욕 알고리즘으로, 선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 방법이다.
searching (검색 알고리즘) - 검색 문제를 해결하는 모든 알고리즘, 일부 데이터 구조 안에 저장된 점보를 검색
Treeset - 이진 탐색 트리(BinarySearchTree)구조로, 추가와 삭제에는 시간이 조금 더 걸리지만 정렬, 검색에 높은 성능을 보이는 자료구조이다.
recursive(재귀 알고리즘) - 하나의 함수에서 자신을 다시 호출하여 작업을 수행하는 알고리즘이다.

hash 
- 내부적으로 배열을 사용해서 데이터를 저장
- 삽입 삭제 시 데이터 이동이 없도록 만들어진 구조 

hashMap
- map 인터페이스의 한 종류로 key-value로 데이터를 저장
- 대용량 데이터 관리에 좋음

힙
 - 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조
 - 여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록 만들어짐
-----------------------------------------------------------------------------------------------------------------------------------
Http와 Htttps의 차이

1. http는 텍스트 교환 방식은 네트워크상에서 정보를 누군가가 마음대로 열람, 수정이 가 / https는 누가 볼수없도록 막음.
2. http방식이 https방식보다 빠르다. 
3. Http방식은 민감한정보를 다룰 때 항상 변조, 해킹 가능성을 생각해야한다. Https는 설치 및 인증서를 유지하는데
추가적인 비용이 발생. -> 따라서, 민감한 정보가 있는 페이지의 경우 Https 그럴필요가없으면 http로 만들면 된다.

-----------------------------------------------------------------------------------------------------------------------------------
OOP의 특징(Object Oriented Programming 객체지향 프로그래밍)

-프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고, 그 객체들 간의 유기적인 
상호작용을 통해 로직을 구성하는 프로그래밍 방법


장점:
-코드 재사용 용이 : 타인이 만든 클래스를 가져다 사용할 수도 있고 상속을 통해 확장 사용가능.

-유지보수 쉬움 : 절차지향프로그래밍에서는 코드를 수정해야할 때 일일이 찾아서 수정. 반면 OOP에서는 
수정해야할 부분이 클래스 내부에 멤버변수나 메서드로 있기 때문에 해당 부분만 수정하면 됨.

-대형프로젝트에 적합 : 클래스단위로 모듈화시켜서 개발할 수 있기 때문에 업무분담 시 용이

단점:

-객체가 많으면 용량이 커질 수 있음
-설계 시 많은 노력과 시간이 필요

특징:
클래스, 인스턴스, 생성자, 오바라이딩, 추상화, 상속, 캡슐화, 다형성, 스레드, 멀티스레드
-----------------------------------------------------------------------------------------------------------------------------------
컴퓨터구조, 운영체제, 데이터베이스, 소프트웨어 공학
https://gyoogle.dev/blog/ 에 나오는 핵심 개념과 면접 질문들에 대답할 정도로 준비
-----------------------------------------------------------------------------------------------------------------------------------
라이브러리와 프레임워크


프레임워크와 라이브러리의 차이점은 흐름을 누가 지니고 있냐의 차이입니다. 
프레임워크는 전체적인 흐름을 자체적으로 가지고 있어 프로그래머는 그 안에서 필요한 코드를 작성합니다. 
반면에 라이브러리는 프로그래머가 전체적인 흐름을 가지고 있어 라이브러리를 자신이 원하는 기능을 구현하고 싶을 때 가져다 
사용할 수 있다는 것

프레임워크는 뼈대나 기반구조를 뜻합니다. 프로그래밍을 진행할 때 필수적인 코드, 알고리즘 등과 같이 어느 정도의 구조를 제공
라이브러리는 특정 기능에 대한 도구 또는 함수들의 집합
-----------------------------------------------------------------------------------------------------------------------------------
CI / CD 구축

CI는 Continuous Integration 
즉, 지속적인 통합이라는 의미입니다.지속적인 통합이란,
어플리케이션의 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어
공유 레포지토리에 통합히는 것을 의미

버그를 신속하게 찾아 해결하고,
소프트웨어의 품질을 개선하고,
새로운 업데이트의 검증 및 릴리즈의 시간을 단축시키는 것

CD는 개발자의 변경 사항이 레포지토리를 넘어, 
고객의 프로덕션(Production) 환경까지 릴리즈 되는 것을 의미합니다. (지속적인배포)

CI에서 예로 든 MSA와 같은 환경에서 Agile 방법론이 적용될 경우,
서비스의 사용자는 최대한 빠른 시간 내에 최신 버전의 Production을 제공받을 필요가 있습니다.
이 때, 소프트웨어가 언제든지 신뢰 가능한 수준의 버전을 유지할 수 있도록 support 하는 것이 CD라고 할 수 있죠.

이는 서비스의 개발팀과 비즈니스팀(영업, CS팀 등) 간의 커뮤니케이션 부족 문제를 해결해 줌으로써,
배포에 이르기까지의 노력을 최소한으로 단축시켜 준다는 Benefit을 제공합니다.
-----------------------------------------------------------------------------------------------------------------------------------
테스트 코드 작성 중요한점

클린코드
클린코드란, 가독성이 높은 코드를 말한다.

네이밍이 잘 되어야 함
오류가 없어야 함
중복이 없어야 함
의존성을 최대한 줄여야 함
클래스 혹은 메소드가 한가지 일만 처리해야 함

리팩토링
프로그램의 외부 동작은 그대로 둔 채, 내부의 코드를 정리하면서 개선하는 것을 말함

리팩토링이 필요한 코드는?
중복 코드
긴 메소드
거대한 클래스
Switch 문
절차지향으로 구현한 코드
리팩토링 작업은 코드의 가독성을 높이고, 향후 이루어질 유지보수에 큰 도움이 된다.

객체지향 특징을 살리려면, switch-case 문을 적게 사용해야 함
리팩토링이 더 큰 의미를 가진 것 같다.
-----------------------------------------------------------------------------------------------------------------------------------
TDD(Test Driven Development) : 테스트주도개발

TDD는 기존 방법과는 다르게, 테스트케이스를 먼저 작성한 이후에 실제 코드를 개발하는 리팩토링 절차를 밟는다.

*장점
작업과 동시에 테스트를 진행하면서 실시간으로 오류 파악이 가능함 ( 시스템 결함 방지 )
짧은 개발 주기를 통해 고객의 요구사항 빠르게 수용 가능. 피드백이 가능하고 진행 상황 파악이 쉬움

(빠르고 정확한 테스트, 배포시 항상 검증)

오류 확인, 불확실성 감소
고객요구에 따른 기능 추가 유연 대처
잘 짜인 테스트는 문서역할


*단점
기존 개발 프로세스에 테스트케이스 설계가 추가되므로 생산 비용 증가
테스트의 방향성, 프로젝트 성격에 따른 테스트 프레임워크 선택 등 추가로 고려할 부분의 증가
(비용,시간)
------------------------------------------------------------------------------------------------------------------------------------

SPA(Single Page Application)
MPA(Multi Page Application)

일반적으로 우리가 웹사이트에 접속하려면, 서버에게 HTML파일에 대한 요청을 보낸다.
그럼 서버는 요청받은 HTML파일의 전송을 담당한다. 

서버는 기존에 이미 index.html과 같은 다양한 HTML파일들을 만들어두고 클라이언트에서 요청하면 각종 프로그래밍 언어를 통해 데이터베이스에서 데이터를 꺼내 
HTML과 비스무리한 ASP, JSP, PHP같은 파일들에 넣어준 후 이걸 HTML형태화 시켜서 전송한다. (물론 데이터베이스가 필요없으면 그냥 HTML만 보낸다.)

혹은 Node.js를 보면 pug, Nunjucks같은 템플릿 엔진을 사용해서 유동적인 HTML파일을 만들어주는 기능도 있다. 이
름은 HTML인데, 안에 데이터베이스로 부터 받은 데이터를 넣어줄 수 있다는 것이다. (과거에는 이게 안 되서 ASP, JSP, PHP같은 확장자를 사용했던 것이다.)

요약하자면, 
기존의 웹은 브라우저는 단지 보여주기만 할 뿐, 요청한 웹 문서에 대한 처리는 전부 서버에서 담당했다는 얘기가 되는데, 이쯤되면 당연히 느껴야 할 얘기가 있다.

그렇다. 서버의 살려달란 소리가 여기까지 들린다는걸 느껴야 한다.
과거에는 웹에서 제공되는 정보가 그렇게 많지 않았다. 많다고 해도 페이지가 많이 나뉘어져 있었기 때문에, 
데이터를 쪼개서 보여줄 수가 있었다. 

하지만 요즘은 하나의 페이지에서 보여줄 수 있는 정보가 정말 무궁무진하게 많다. 
일단 모니터도 커졌고, 자바스크립트 기술도 발전하고, 컴퓨터 성능도 좋아지고 등등의 이유로 더 많은 정보를 한 번에 보여줄 수가 있게 되었다.

그 결과, 
페이지를 이동할 때마다 매번 새로운 정보를 보여줘야 하는 
서버 측에선 죽을 맛이 되었다. 
심지어 사용자가 늘어남에 따라 모든 사용자가 서버로 하여금 각각 본인들의 페이지를 만들어서 달라고하니 
서버 쪽에선 과부하가 걸릴 수 밖에 없다.

또, 이 MPA(Multi Page Application)의 단점은, 페이지 전환마다
새로운 HTML파일을 계속해서 요청하면, 사용자의 인터페이스에서 사용하고 있던 상태를 유지하기가 번거로워지고, 
바뀌지 않는 부분까지 다시 불러와야 하기 때문에, 불필요한 로딩도 생긴다.



SPA의 등장
SPA는 이런것들을 해결하기 위해 서버에서 사용자에게 보여줄 파일을 쿵짝쿵짝 하는게 아니라, 
브라우저에서 해결하도록 만든 것이다.

그렇다. 자바스크립트는 DOM을 건드릴 수 있는 스크립트 언어이고, 
웹 브라우저에서 쓰이는 유일한 프로그래밍 언어이다. 

단 하나의 index.html 파일만 가지고, 안의 내용물들은 전부 .js파일의 DOM 조작을 통해 채우게 된다.

아니, 그럼 데이터베이스는 어쩔건데?
그렇다. 페이지의 렌더링을 프론트에서 담당하게 되면 이 부분이 반드시 의아해져야 한다.
위에도 적었듯 과거에는 서버에 담긴 .jsp파일이 있다면, 
서버는 자바코드를 통해 데이터베이스와 연결해 데이터를 가져와 이 .jsp파일에 담긴 결과물을 html처럼 만들어준 후, 사용자에게 보내주었다.

그런데, 어떻게 프론트엔드에서 자바스크립트로 이걸 해결할 수 있을까?
여기서 사용하는게 대체적으로 REST API이다.

프론트는 자바스크립트와 URL을 이용해서 서버에게 데이터를 요청하고 응답받는다.
SPA에서는 웹 페이지가 자바스크립트로 인해 렌더링된다.
서버는 URL을 통해 들어온 요청에 대한 응답만 해주면 되고, 이때 METHOD를 살핀다.
METHOD 종류로는 GET, POST, PATCH, PUT, DELETE 등이 있다


====> 결론 주소가 변경될 때마다 html,css,js,백엔드와의 통신 요구 
====> spa로 바뀌면서 해당 부분을 브라우저에게 일부 위임 단 하나의 html을 가지고 온다 그 후 주소에 맞는 js들을 호출

------------------------------------------------------------------------------------------------------------------------------------
=>  모른다고 기 죽거나 면접 망했다..! 하실 필요 전혀 없습니다. 모를 때 까지 물어보는 것 같거든요 😅

 CS 관련 지식도 꼭 물어봅니다. 자료구조 운영체제 알고리즘 데이터베이스 소프트웨어 공학 컴퓨터구조 이 넓은 분야에서 아주 기초적인 지식
https://gyoogle.dev/ 

EX) 데이터베이스에서 Transaction이 뭔가요?
위 사이트에 가시면 면접에 필요한 기초 CS 지식들이 정리되어있습니다
------------------------------------------------------------------------------------------------------------------------------------
 
