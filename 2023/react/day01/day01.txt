
React?
    복잡한 사용자 인터페이스(UI)를 쉽게 구축하기 위해 페이스북에서 제작한 라이브러리

라이브러리? (도서관 = 모듈들의 집합)
    
    프레임워크와 라이브러리의 차이점

        * 프레임워크
            코드를 작성할 때 필요한 틀을 제공해주는 것 따라서 개발을 할 때
            제어권이 개발자가 아닌 프레임워크에 존재, 개발할 때 프레임워크가 가지고 있는 규칙에 의해 작성
        ex) spring, django, nextJS, nuxtJS ...

        * 라이브러리
            같은 로그인 로직이라고 하더라도 passportJS, gotrue, 즉 사용자는 특정 정해져있는 코드를 사용하는
            것이 아니라, 필요로 하는 라이브러리를 선택해서 코드에 적용
        ex) nodeJS 설치되는 모든 패키지와, reactJS, jquery

        단점 : 안정성이 낮다
        
                - 라이브러리는 삭제되면 만약에 운영중이던 시스템이 다운되어 그것을 복구(핫픽스)를 하는데 어려움이 있다.
                    물론 다른 개발자가 빠르게 만들기는 한다.

--------------------------------------------------------------------------------------------------------------------------

React의 JS 구동원리 핵심 컨셉

Components(레고 조각같은 느낌으로 설명하심)
- 하나의 페이지를 한 가지 이상의 기능을 수행하는 UI 단위로 분리한 것
- 재사용이 용이하고 관리 및 유지 보수에 효율적

Virtual DOM(가상 돔(document model))
- react가 가지고 있는 가상 돔, 돔의 복사본
- state(상태)를 react에서 구독, 만약 state에 변화가 생긴다면 그 때
  가상돔과 실제돔을 비교하여 수정된 부분만을 실제돔에 리랜더링


1. state에 변화가 생긴다면
2. 수정된 부분(컴포넌트)만을 실제 돔에 리랜더링
(렌더링 최적화)

key point

state(상태를 가짐)
Components(UI 분리)
Virtual DOM(re 랜더링)

React 쓰는 이유
    Components라는 개념을 이용해 페이지마다 같은 내용을 번거롭게 여러번 코딩할 필요가 없다.

--------------------------------------------------------------------------------------------------------------------------

CSR, SSR

CSR (Client Side Rendering)
    * 사용자가 웹페이지를 그린다
    사용자가 웹 페이지 접속 -> 프론트엔드 서버에 페이지를 랜더링할 때 필요한 리소스 전달

    ex) 페이지가 로드 되었을 때 상품 목록을 그려준다.
        이 상품 목록은 백엔드 서버로부터 응답 받은 데이터이다.

    위의 과정을 사용자가 하게되는 것
    사용자가 랜더링을 부담

    장점
        페이지에 필요한 리소스들을 사전에 미리 불러와 데이터를 캐싱(저장)하고 있다가
        URL에 맞는 페이지를 보여주기 때문에 초기 랜더링 이후의 랜더링 속도가 빠르다

    단점
        초기 페이지 로딩이 SSR보다 느리다.
        SEO(검색엔진최적화)에 불리
        검색엔진에 노출이 필요한 사이트 부적합 (페이지가 검색엔진이 검색하였을 때 빈화면이 노출)

SSR (Server Side Rendering)
    * 서버에서 페이지를 그린다.
    사용자가 웹 페이지에 접속 -> 서버에서 페이지를 랜더링 -> 랜더링된 페이지를 사용자에게 전달
    js가 로드 되기도 전에 완성된 페이지를 사용자가 먼저 확인

    장점
        SEO 최적화에 유리 => 웹 사이트를 검색엔진이 크롤링하여 사용자에 제공 가능
        빠른 완성본 페이지 로딩 속도
        서버에서 렌더링을 부담하기 때문에 사용자가 느끼는 부담이 덜하다

    단점
        서버의 부담 (생산 비용 증가)
        무거운 페이지라면 오히려 초기 로딩이 CSR보다 오래 걸릴 가능성
        CSR보다 더 많은 생산비용, 추가 러닝 커브

React는 대표적인 CSR, SPA

--------------------------------------------------------------------------------------------------------------------------

SPA, MPA

    SPA (Single Page Application)

        페이지가 하나인 애플리케이선(.html 파일이 1개)
        reactJS와 같은 컴포넌트 기반 라이브러리 및 프레임워크는 SPA에 최적화
        사용자가 웹 사이트에 접속 당시 번들링 된 리소들을 한번에 전달

        그리고 이를 캐싱해두었다가 url이 달라짐에 따라 html의 내부를 수정하여
        사용자에게 보내주는 것

        따라서 통상적으로 react의 파일 구조는 index.html 하나로만 구성되어 있음

    MPA (Multi Page Application)

        페이지가 여러개인 애플리케이션 (.html 파일이 여러개)
        보통은 SSR 방식으로 요청한다 해당 페이지에 필요한 리소스를 불러온다.

--------------------------------------------------------------------------------------------------------------------------

* React는 CSR에 SPA에 최적화 되어있다.

--------------------------------------------------------------------------------------------------------------------------

    패키지 관리툴

        라이브러리들을 관리하고 설치할 수 있는 도구
        npm, npx, yarn, yarn berry

    * npm
        nodejs에서 기본적으로 내장되어 있는 패키지 관리 툴
        ex) npm i(install) 라이브러리명 (--save) 설치
            npm rm(remove) 라이브러리명 - 삭제

            npm i -g 라이브러리명 (노드 환경 전역에서 설치)
            npm i -D 라이브러리명 (개발환경에서만 사용할 라이브러리를 설치)

            ex) 디버깅툴은? 개발자만 == 사용자 굳이 볼 필요

    nodeJS
    https://nodejs.org/ko/

    설치 확인
    node -v

    * npx
        npm과 달리 설치하지않고 라이브러리를 실행 시켜주는 도구
        사실 개발하는 입장이라면 npm과 npx 차이를 느끼지 몰할 수도 있음
        단, npx를 사용해야하는 경우는 내 프로젝트에 설치하지 않고
        일회성으로 무거운 패키지를 사용해야하 때 설치하지 않고 실행하는 패키지 관리 툴
        npx도 마찬가지로 npm에 기본 설치(5.2v 이상)

        ex) npx create-react-app 프로젝트명 : react 프로젝트를 생성하는 명령어 (CRA)

    * yarn
        과거에는 npm보다, 속도, 안정성, 보안 모두 뛰어나서 이목을 끌었다 npm의 잦은 업데이트로
        현재는 거의 차이가 없는 상태, 보안성은 제외

    * yarn berry
        npm과 yarn의 경우는 설치된 라이브러리들은 node_moduels라고하는 파일에 저장
        pnp 방식을 도입 zero install
        알집으로 파일을 관리하고 있기 때문에 프로젝트 자체가 가볍고 빌드가 빨라진다.

        ** 모노레포
        => 하나의 워크스페이스(폴더)를 통해 여러개의 프로젝트를 담고 관리할 수 있음

        본래 모노레포는 yarn와 turbo 라이브러리르 통해 구축하였으나
        yarn berry는 보다 모노레포에 최적화 되어있는 패키지 관리 툴

        그러나, 다른 프로젝트를 한 폴더에 둔다는 것을 폴더의 구조나 신경써야하는 부분들이
        배로 늘어난다는 이야기 따라서 초기에 적용하지 않는 것은 좋지 않고 이미 사용자가
        충분히 확보된 복잡한 프로젝트를 간단하게 만들기 위해 사용

--------------------------------------------------------------------------------------------------------------------------

* React 생성

1. 터미널 명령어를 통해 내가 프로젝트를 생성하고자 하는 위치 경로를 맞춰야 함

2. 명령어
    create-react-app (CRA) webpack5(번들링도구)
    
    vite esBuild
    초보자가 사용하기에 적합지 않음
    CRA는 react에서 직접 만든 명령어 굉장히 편리한 라이브러리들이 이미 설치 및 셋팅

    CRA는 React에 필요한 모든 설정 파일을 대신 설정 (웹팩과 같은 번들링도구, 바벨과 같은 트랜스파일러)
    
    단점, 이미 설치된 도구를 커스텀하기 힘들다. 보통의 경우 커스텀을 할 때는
    carco와 같은 cra 정용 설정 라이브러리를 통해 커스텀 해야한다.

3. npx create-react-app 프로젝트명(ex1)
    * 폴더 경로 꼭 확인
    cd ex1
    npm start

    * react 실행의 기본 port는 3000번
    따라서 프로젝트 실행 시 기본 주소는 http://localhost:3000/
                                            ---------
                                                127.0.0.1

    여러분이 프로젝트가 실행 중일 때는 3001, 3002, 3003

--------------------------------------------------------------------------------------------------------------------------

webpack

    모듈 번들러
        모둘 => 한가지 이상의 기능을 하는 분리된 코드의 집합, 덩어리
        번들어 => 묶어주는 것

        html, css, js, img
        너저분하게 분리되어있는 리로스들을 확장자명 혹은 특정 기준으로 분류하고 묶어주는 역할

        모듈 번들어인 웹팩을 사용하면 잘 정돈 되어있는 데이터에서 필요한 리소스만 찾을 수 있기 때문에
        네트워크 연산 비용이 줄어들게 됨

        1. 모듈 단위의 개발이 가능
        2. 네트워크 연산 비용 감소
        3. loader라는 기능을 통해 js가 로드할 수 없는 파일도 로드할 수 있는 상태로 컴파일(변환)


babel

    트랜스파일러 (번역기)
    
    ES6(ES2015) 이후 - 모던 자바스크립트
    es-nextJS
    es-2020

    최신 문법들을 이해하지 못하는 웹 브라우저 로더들이 해당 언어를 이해할 수 있도록
    저레벨의 문법으로 트랜스파일하여 이해할 수 있도록 변환

    * react에서 babel 중 4가지 모듈을 사용

    1. @babel/core 바벨을 구동시키기 위한 핵심 요소
    2. @babel/cli  명령어를 통해 cmd에서 바벨 명령어 사용 가능      
    3. @babel/preset-env 바벨의 가장 기본적인 설정들
    4. @babel/preset-react 바벨을 JSK문법도 이해할 수 있도록 해주는 모듈

    JSX (react 문법)

--------------------------------------------------------------------------------------------------------------------------

    * 개발자로서의 가치관 ?
        
        협업 가능한 개발자
        변화에 긴밀하게 적응할 수 있는 개발자
        클린 코드를 작성할 수 있는 개발자
        안되는 것에 대한 두려움을 극복하고자 하는 자세를 가진 사람
        어려운 코드를 쉽게 설명할 수 있는 개발자
        오픈마인드 긍정적인 사고를 가진 개발자
        문제를 해결하는 사람

        비즈니스를 이해하고 생산성에 기여하는 개발자

    * 생산성 있는 개발자 ?
        가치 및 이익을 창출할 수 있는 개발자
        
--------------------------------------------------------------------------------------------------------------------------

리액트 프로젝트 구조

    node_modules - 현재 프로젝트에 설치된 라이브러리들의 실제 파일
                    용량이 높은편 그래서 git에는 올리지 않습니다.

    public - 정적 파일 보관소 (index.html, favicon, seo)
    ** src - 개발이 진행될 곳
    .gitignore - git에 올라가지 말아야할 파일
    package.json - 설치된 라이브러리의 목록과 버전을 관리, 실행 스크립트(명령어)와 프로젝트 설정
    package-lock.json - 라이브러리 설치 시, 라이브러리 설치에 필요한 정확한 정보
    READEME.md

    * npm install


--------------------------------------------------------------------------------------------------------------------------

    src의 구조

--------------------------------------------------------------------------------------------------------------------------