
MSW (Mocking Service Worker)
    - 가상 Service Worker (웹페이지와 브라우저의 사이에서 일하는 일꾼)
    - 오프라인 캐싱, 푸시 알림, 동기화

    Service Worker를 가상을 만들어서 실제 서비스 워커 대신 사용가능

    사용할 기능
    1. MSW를 활용하여 Mocking API 만들기

        백엔드가 없어도 프론트 내에서 API(Http 요청)을 통한 데이터 교환을 할 수 있음

        1) 개발 초기 단계에서 백엔드 없이 빠르게 프로토타입 제작이 가능
            => 백엔드 없이 실제 백엔드에서 받는 것과 유사한 mock data를 생성하여
                마치 실제 백엔드가 존재하는 것처럼 프론트엔드 구상


                ⭐ 프론트엔드 개발자가 갖추어야할 것
                    내가 구상하려는 화면에서 백엔드에서 받아와야하는 데이터가 무엇인지 알고 있어야함
                    그리고 이를 json 데이터로 만들 줄 알아야합니다.

                    {
                        name: "김성용",
                        age: 20,
                        height:190
                    }

        2) MockApi 테스트, 프론트엔드 -> 테스트 코드 작성 -> 실제 API
                API가 서버가 다운되어도 Mock API를 사용하여 개발 가능
                
        3) API의 응답속도가 느릴 경우 대체 가능, 개발자가 더 빠르게 개발 및 테스트 수행이 가능

        4) 다양한 시뮬레이션이 가능

        => Mocking Api를 활용하여 개발 및 테스트의 효율성을 높이고
        코드의 안정성과 견고성을 높일 수 있음

--------------------------------------------------------------------------------------------------------------

    redux-middleware (중간통로)

        redux는 동기적인 작업을 처리하는 것
        그러나 실제 개발을 할 때는 비동기 데이터 작업을 많이 다루게 됩니다.
        따라서 dispatch가 특정한 값을 전달하면 middleware에서 비동기 작업 처리 후
        결과값을 store에 전달

    const res = await TodoService.getTodo()
    dispatch({
        type: "GET_TODO",
        payload: res.data.data
    })

    ---------------------------------------> dispatch 이후에 실행해향하는 로직이 있다면?

    dispatch({
        type: "GET_TODO"
    })

    ---------------------------------------> redux-saga, redux-thunk

    그러나 RTK(Redux-toolkit) 에서는 thunk를 기본으로 하고 있으며
    기존 thunk보다 훨씬 더 간편하게 코드 구현이 가능하기에

    saga의 사용 빈도가 급격히 줄어들고 있음

-------------------------------------------------------------------------------------------------------------

npm i msw 

-------------------------------------------------------------------------------------------------------------

env -- 로컬에 개발 가능? (환경변수 설정)
prettier, eslint가 적용이 안된다 => setting.json 달라고 하면 된다.

-------------------------------------------------------------------------------------------------------------

eslint, prettier

npm i -D prettier eslint eslint-plugin-prettier eslint-plugin-react eslint-plugin-unused-imports

-------------------------------------------------------------------------------------------------------------

husky

eslint와 prettier을 파일로 만들어 사용하고 있지만, 모든 파일을 실시간으로 감시할 수는 없는 법
따라서, push 및 commit 하기 전에 lint:fix나 format 명령어를 자동 실행할 수 있게 하는 친구

- pre-commit
- pre-push

커밋과 푸쉬 하기 전에 실행할 터미널 명령어가 있다면 쓰는 라이브러리

-------------------------------------------------------------------------------------------------------------

npm i -D husky
- git이 없으면 git init 후 사용 (그러나 보통 CRA로 프로젝트 생성 시 자체 생성 됨)
npx husky install

.husky 폴더 생성되어야 함

-------------------------------------------------------------------------------------------------------------

package.json에 아래 추가하면 
git repository를 clone하고 npm i를 할 때 husky도 같이 설치가 됨

    "scripts": {
        "postinstall": "husky install",
    }



-------------------------------------------------------------------------------------------------------------

이 이후 pre-commit 명령어와 pre-push 명령어 설정

npx husky add .husky/pre-commit "npm run format"
npx husky add .husky/pre-push "npm run lint:fix"

-------------------------------------------------------------------------------------------------------------(설정 시 단한번만)
                                                                                                            (클론 받은 사람은 안해도 됨)

깃허브에 커밋 푸쉬 하시면 자동으로 위에 설정한 터미널 명령어 실행

-------------------------------------------------------------------------------------------------------------




